# 🚀 7日間マスタープログラム
## AI画像チャットアプリを一人で作れるようになるまでの最短ロードマップ

---

## 📋 事前準備（30分）

### 必要なツール

```bash
# Python 3.8以上がインストールされているか確認
python --version

# VSCodeをインストール（推奨）
# https://code.visualstudio.com/

# VSCode拡張機能（推奨）
# - Python
# - Pylance
# - Live Server
```

### フォルダー構成を作成

```bash
mkdir flask-learning
cd flask-learning
```

---

## 📅 Day 1: Flask基礎（2時間）

### 🎯 目標
- Flaskの基本を理解
- ルーティングとテンプレートを習得
- シンプルなWebアプリを作成

### ステップ1.1: Hello World（15分）

**app.py**
```python
from flask import Flask

app = Flask(__name__)

@app.route('/')
def hello():
    return "Hello, Flask!"

if __name__ == '__main__':
    app.run(debug=True)
```

```bash
pip install flask
python app.py
# ブラウザで http://localhost:5000 を開く
```

**理解すべきポイント:**
- `@app.route('/')` = URLパスを指定
- `def hello()` = そのURLにアクセスしたときの処理
- `debug=True` = コード変更を自動反映

---

### ステップ1.2: テンプレートの使用（30分）

**ディレクトリ構成**
```
flask-learning/
├── app.py
└── templates/
    └── index.html
```

**app.py**
```python
from flask import Flask, render_template

app = Flask(__name__)

@app.route('/')
def index():
    message = "Flaskからのメッセージ"
    return render_template('index.html', message=message)

if __name__ == '__main__':
    app.run(debug=True)
```

**templates/index.html**
```html
<!DOCTYPE html>
<html>
<head>
    <title>Flask学習</title>
</head>
<body>
    <h1>{{ message }}</h1>
    <p>これはFlaskのテンプレートです</p>
</body>
</html>
```

**理解すべきポイント:**
- `render_template()` = HTMLファイルを返す
- `{{ message }}` = Pythonの変数をHTMLに埋め込む
- `templates/` フォルダーは必須

---

### ステップ1.3: POSTリクエストの処理（45分）

**app.py**
```python
from flask import Flask, render_template, request

app = Flask(__name__)

@app.route('/')
def index():
    return render_template('form.html')

@app.route('/submit', methods=['POST'])
def submit():
    name = request.form.get('name')
    message = request.form.get('message')
    return f"こんにちは、{name}さん！メッセージ: {message}"

if __name__ == '__main__':
    app.run(debug=True)
```

**templates/form.html**
```html
<!DOCTYPE html>
<html>
<head>
    <title>フォーム送信</title>
</head>
<body>
    <h1>フォームを送信</h1>
    <form action="/submit" method="POST">
        <input type="text" name="name" placeholder="名前">
        <textarea name="message" placeholder="メッセージ"></textarea>
        <button type="submit">送信</button>
    </form>
</body>
</html>
```

**理解すべきポイント:**
- `methods=['POST']` = POSTリクエストを受け付ける
- `request.form.get()` = フォームデータを取得
- `action="/submit"` = 送信先のURL

---

### ステップ1.4: JSONレスポンス（30分）

**app.py**
```python
from flask import Flask, jsonify, request

app = Flask(__name__)

@app.route('/api/hello', methods=['GET'])
def api_hello():
    return jsonify({
        'message': 'Hello, API!',
        'status': 'success'
    })

@app.route('/api/echo', methods=['POST'])
def api_echo():
    data = request.json
    return jsonify({
        'received': data,
        'status': 'success'
    })

if __name__ == '__main__':
    app.run(debug=True)
```

**テスト（ブラウザのコンソールで）**
```javascript
// GET リクエスト
fetch('/api/hello')
    .then(res => res.json())
    .then(data => console.log(data));

// POST リクエスト
fetch('/api/echo', {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({message: 'テスト'})
})
    .then(res => res.json())
    .then(data => console.log(data));
```

**理解すべきポイント:**
- `jsonify()` = PythonのdictをJSONに変換
- `request.json` = JSONデータを取得
- APIはHTMLではなくJSONを返す

---

### 🎓 Day 1 チャレンジ

以下のアプリを作成してみよう：

**仕様:**
1. テキストを入力できるフォーム
2. 送信すると文字数をカウントして表示
3. `/api/count` でJSON形式でも返す

**ヒント:**
```python
text = request.form.get('text')
count = len(text)
```

---

## 📅 Day 2: フロントエンド基礎（2.5時間）

### 🎯 目標
- HTML/CSS/JavaScriptの連携を理解
- Fetch APIでサーバーと通信
- 動的にページを更新

### ステップ2.1: 基本構造（30分）

**templates/chat.html**
```html
<!DOCTYPE html>
<html>
<head>
    <title>チャット練習</title>
    <style>
        body {
            font-family: sans-serif;
            max-width: 600px;
            margin: 50px auto;
        }
        #messages {
            border: 1px solid #ccc;
            height: 300px;
            overflow-y: auto;
            padding: 10px;
            margin-bottom: 10px;
        }
        .message {
            padding: 5px;
            margin: 5px 0;
            border-radius: 5px;
        }
        .user {
            background: #e3f2fd;
            text-align: right;
        }
        .bot {
            background: #f5f5f5;
        }
        #input-area {
            display: flex;
            gap: 10px;
        }
        #input-area input {
            flex: 1;
            padding: 10px;
        }
        #input-area button {
            padding: 10px 20px;
        }
    </style>
</head>
<body>
    <h1>チャット練習</h1>
    <div id="messages"></div>
    <div id="input-area">
        <input type="text" id="messageInput" placeholder="メッセージを入力...">
        <button onclick="sendMessage()">送信</button>
    </div>

    <script>
        function addMessage(text, type) {
            const messagesDiv = document.getElementById('messages');
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message ' + type;
            messageDiv.textContent = text;
            messagesDiv.appendChild(messageDiv);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }

        function sendMessage() {
            const input = document.getElementById('messageInput');
            const message = input.value;
            
            if (!message) return;
            
            // ユーザーメッセージを表示
            addMessage(message, 'user');
            input.value = '';
            
            // ボットの返信をシミュレート
            setTimeout(() => {
                addMessage('あなたは「' + message + '」と言いました', 'bot');
            }, 500);
        }

        // Enterキーで送信
        document.getElementById('messageInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') sendMessage();
        });
    </script>
</body>
</html>
```

**app.py**
```python
from flask import Flask, render_template

app = Flask(__name__)

@app.route('/')
def chat():
    return render_template('chat.html')

if __name__ == '__main__':
    app.run(debug=True)
```

**理解すべきポイント:**
- `document.getElementById()` = HTML要素を取得
- `createElement()` = 新しい要素を作成
- `appendChild()` = 要素を追加
- `addEventListener()` = イベントを監視

---

### ステップ2.2: Fetch APIでサーバーと通信（1時間）

**app.py**
```python
from flask import Flask, render_template, jsonify, request

app = Flask(__name__)

@app.route('/')
def chat():
    return render_template('chat_api.html')

@app.route('/api/chat', methods=['POST'])
def api_chat():
    data = request.json
    user_message = data.get('message', '')
    
    # シンプルなボットロジック
    if 'こんにちは' in user_message:
        response = 'こんにちは！元気ですか？'
    elif '天気' in user_message:
        response = '今日は良い天気ですね！'
    else:
        response = f'「{user_message}」と言いましたね。'
    
    return jsonify({
        'response': response,
        'status': 'success'
    })

if __name__ == '__main__':
    app.run(debug=True)
```

**templates/chat_api.html**
```html
<!DOCTYPE html>
<html>
<head>
    <title>APIチャット</title>
    <style>
        /* 前のスタイルをコピー */
    </style>
</head>
<body>
    <h1>APIチャット</h1>
    <div id="messages"></div>
    <div id="input-area">
        <input type="text" id="messageInput" placeholder="メッセージを入力...">
        <button onclick="sendMessage()">送信</button>
    </div>

    <script>
        function addMessage(text, type) {
            const messagesDiv = document.getElementById('messages');
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message ' + type;
            messageDiv.textContent = text;
            messagesDiv.appendChild(messageDiv);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }

        async function sendMessage() {
            const input = document.getElementById('messageInput');
            const message = input.value;
            
            if (!message) return;
            
            // ユーザーメッセージを表示
            addMessage(message, 'user');
            input.value = '';
            
            try {
                // サーバーにリクエスト
                const response = await fetch('/api/chat', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({message: message})
                });
                
                const data = await response.json();
                
                // ボットの返信を表示
                addMessage(data.response, 'bot');
            } catch (error) {
                console.error('Error:', error);
                addMessage('エラーが発生しました', 'bot');
            }
        }

        document.getElementById('messageInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') sendMessage();
        });
    </script>
</body>
</html>
```

**理解すべきポイント:**
- `async/await` = 非同期処理を同期的に書く
- `fetch()` = サーバーにリクエストを送る
- `JSON.stringify()` = JavaScriptオブジェクトをJSONに変換
- `try/catch` = エラーハンドリング

---

### ステップ2.3: ローディング表示（30分）

**chat_api.html に追加**
```html
<style>
    .loading {
        color: #999;
        font-style: italic;
    }
</style>

<script>
    function showLoading() {
        const messagesDiv = document.getElementById('messages');
        const loadingDiv = document.createElement('div');
        loadingDiv.className = 'message bot loading';
        loadingDiv.id = 'loading';
        loadingDiv.textContent = '入力中...';
        messagesDiv.appendChild(loadingDiv);
        messagesDiv.scrollTop = messagesDiv.scrollHeight;
    }

    function hideLoading() {
        const loadingDiv = document.getElementById('loading');
        if (loadingDiv) {
            loadingDiv.remove();
        }
    }

    async function sendMessage() {
        const input = document.getElementById('messageInput');
        const message = input.value;
        
        if (!message) return;
        
        addMessage(message, 'user');
        input.value = '';
        
        showLoading();  // ← 追加
        
        try {
            const response = await fetch('/api/chat', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({message: message})
            });
            
            const data = await response.json();
            
            hideLoading();  // ← 追加
            addMessage(data.response, 'bot');
        } catch (error) {
            hideLoading();  // ← 追加
            console.error('Error:', error);
            addMessage('エラーが発生しました', 'bot');
        }
    }
</script>
```

---

### 🎓 Day 2 チャレンジ

以下の機能を追加してみよう：

1. メッセージをクリアするボタン
2. メッセージの送信時刻を表示
3. 送信ボタンを無効化（送信中は押せないように）

---

## 📅 Day 3: Gemini API連携（2時間）

### 🎯 目標
- 外部APIの使い方を理解
- Gemini APIで会話を生成
- エラーハンドリングを実装

### ステップ3.1: APIキーの取得（10分）

1. [Google AI Studio](https://makersuite.google.com/app/apikey) にアクセス
2. 「Create API Key」をクリック
3. APIキーをコピー

**.env ファイルを作成**
```bash
GOOGLE_AI_API_KEY=あなたのAPIキー
```

**依存関係をインストール**
```bash
pip install google-genai python-dotenv
```

---

### ステップ3.2: Gemini APIの基本（30分）

**test_gemini.py**
```python
import os
from dotenv import load_dotenv
from google import genai
from google.genai import types

# 環境変数を読み込み
load_dotenv()
API_KEY = os.getenv("GOOGLE_AI_API_KEY")

# クライアント初期化
client = genai.Client(api_key=API_KEY)

# テキスト生成
response = client.models.generate_content(
    model="gemini-2.0-flash-exp",
    contents="こんにちは！",
    config=types.GenerateContentConfig(
        temperature=0.7,
        max_output_tokens=1024,
    )
)

print(response.text)
```

```bash
python test_gemini.py
```

**理解すべきポイント:**
- `load_dotenv()` = .envファイルから環境変数を読み込み
- `os.getenv()` = 環境変数を取得
- `temperature` = 応答のランダム性（0-1）
- `max_output_tokens` = 最大応答長

---

### ステップ3.3: FlaskアプリにGeminiを統合（1時間）

**app.py**
```python
import os
from flask import Flask, render_template, jsonify, request
from dotenv import load_dotenv
from google import genai
from google.genai import types

load_dotenv()
API_KEY = os.getenv("GOOGLE_AI_API_KEY")
client = genai.Client(api_key=API_KEY)

app = Flask(__name__)

@app.route('/')
def chat():
    return render_template('gemini_chat.html')

@app.route('/api/chat', methods=['POST'])
def api_chat():
    try:
        data = request.json
        user_message = data.get('message', '')
        
        # Gemini APIで応答生成
        response = client.models.generate_content(
            model="gemini-2.0-flash-exp",
            contents=user_message,
            config=types.GenerateContentConfig(
                temperature=0.7,
                max_output_tokens=1024,
            )
        )
        
        return jsonify({
            'response': response.text,
            'status': 'success'
        })
    
    except Exception as e:
        print(f"Error: {e}")
        return jsonify({
            'response': 'エラーが発生しました',
            'status': 'error'
        }), 500

if __name__ == '__main__':
    app.run(debug=True)
```

**templates/gemini_chat.html**
```html
<!-- chat_api.html と同じ -->
```

---

### ステップ3.4: 会話履歴の保持（30分）

**app.py（改良版）**
```python
import os
from flask import Flask, render_template, jsonify, request, session
from dotenv import load_dotenv
from google import genai
from google.genai import types

load_dotenv()
API_KEY = os.getenv("GOOGLE_AI_API_KEY")
client = genai.Client(api_key=API_KEY)

app = Flask(__name__)
app.secret_key = 'your-secret-key'  # 本番環境では安全な鍵を使用

# メモリ内で会話履歴を保持
conversations = {}

@app.route('/')
def chat():
    return render_template('gemini_chat.html')

@app.route('/api/chat', methods=['POST'])
def api_chat():
    try:
        data = request.json
        user_message = data.get('message', '')
        session_id = data.get('session_id', 'default')
        
        # 会話履歴を取得または作成
        if session_id not in conversations:
            conversations[session_id] = []
        
        # 会話履歴に追加
        conversations[session_id].append(user_message)
        
        # 履歴を含めてプロンプトを作成
        full_prompt = "\n".join(conversations[session_id])
        
        # Gemini APIで応答生成
        response = client.models.generate_content(
            model="gemini-2.0-flash-exp",
            contents=full_prompt,
            config=types.GenerateContentConfig(
                temperature=0.7,
                max_output_tokens=1024,
            )
        )
        
        # 応答も履歴に追加
        conversations[session_id].append(response.text)
        
        return jsonify({
            'response': response.text,
            'status': 'success'
        })
    
    except Exception as e:
        print(f"Error: {e}")
        return jsonify({
            'response': 'エラーが発生しました',
            'status': 'error'
        }), 500

if __name__ == '__main__':
    app.run(debug=True)
```

---

### 🎓 Day 3 チャレンジ

以下の機能を追加してみよう：

1. ユーザーが温度（temperature）を調整できるスライダー
2. 会話履歴をクリアする機能
3. エラーメッセージをユーザーフレンドリーに表示

---

## 📅 Day 4: ファイルアップロード（2.5時間）

### 🎯 目標
- ファイルアップロードの仕組みを理解
- 画像を保存・表示
- 画像とテキストを一緒に送信

### ステップ4.1: 基本的なファイルアップロード（45分）

**app.py**
```python
from flask import Flask, render_template, request, jsonify
from werkzeug.utils import secure_filename
import os

app = Flask(__name__)
app.config['UPLOAD_FOLDER'] = 'uploads'
app.config['MAX_CONTENT_LENGTH'] = 16 * 1024 * 1024  # 16MB制限

ALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg', 'gif'}

# uploadsフォルダーを作成
os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)

def allowed_file(filename):
    return '.' in filename and \
           filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

@app.route('/')
def upload_form():
    return render_template('upload.html')

@app.route('/api/upload', methods=['POST'])
def upload_file():
    if 'file' not in request.files:
        return jsonify({'error': 'ファイルがありません'}), 400
    
    file = request.files['file']
    
    if file.filename == '':
        return jsonify({'error': 'ファイル名が空です'}), 400
    
    if file and allowed_file(file.filename):
        filename = secure_filename(file.filename)
        filepath = os.path.join(app.config['UPLOAD_FOLDER'], filename)
        file.save(filepath)
        
        return jsonify({
            'message': 'アップロード成功',
            'filename': filename
        })
    
    return jsonify({'error': '無効なファイル形式です'}), 400

if __name__ == '__main__':
    app.run(debug=True)
```

**templates/upload.html**
```html
<!DOCTYPE html>
<html>
<head>
    <title>ファイルアップロード</title>
</head>
<body>
    <h1>画像アップロード</h1>
    <input type="file" id="fileInput" accept="image/*">
    <button onclick="uploadFile()">アップロード</button>
    <div id="result"></div>

    <script>
        async function uploadFile() {
            const fileInput = document.getElementById('fileInput');
            const file = fileInput.files[0];
            
            if (!file) {
                alert('ファイルを選択してください');
                return;
            }
            
            const formData = new FormData();
            formData.append('file', file);
            
            try {
                const response = await fetch('/api/upload', {
                    method: 'POST',
                    body: formData
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    document.getElementById('result').innerHTML = 
                        `アップロード成功: ${data.filename}`;
                } else {
                    document.getElementById('result').innerHTML = 
                        `エラー: ${data.error}`;
                }
            } catch (error) {
                console.error('Error:', error);
                alert('アップロードエラー');
            }
        }
    </script>
</body>
</html>
```

**理解すべきポイント:**
- `FormData` = ファイルを送信するための特別な形式
- `secure_filename()` = ファイル名を安全にする
- `request.files` = アップロードされたファイルを取得
- `file.save()` = ファイルを保存

---

### ステップ4.2: 画像プレビュー（30分）

**upload.html に追加**
```html
<style>
    #preview {
        margin-top: 20px;
    }
    #preview img {
        max-width: 300px;
        border: 1px solid #ccc;
        border-radius: 5px;
    }
</style>

<div id="preview"></div>

<script>
    // ファイル選択時にプレビュー表示
    document.getElementById('fileInput').addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = (event) => {
                document.getElementById('preview').innerHTML = 
                    `<img src="${event.target.result}" alt="プレビュー">`;
            };
            reader.readAsDataURL(file);
        }
    });
</script>
```

**理解すべきポイント:**
- `FileReader` = ファイルをブラウザで読み込む
- `readAsDataURL()` = 画像をBase64形式に変換
- `event.target.result` = 読み込まれたデータ

---

### ステップ4.3: 画像の表示（45分）

**app.py に追加**
```python
from flask import send_from_directory

@app.route('/uploads/<filename>')
def uploaded_file(filename):
    return send_from_directory(app.config['UPLOAD_FOLDER'], filename)
```

**templates/image_gallery.html**
```html
<!DOCTYPE html>
<html>
<head>
    <title>画像ギャラリー</title>
    <style>
        .gallery {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 10px;
            margin-top: 20px;
        }
        .gallery img {
            width: 100%;
            height: 200px;
            object-fit: cover;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <h1>アップロード画像</h1>
    <input type="file" id="fileInput" accept="image/*" multiple>
    <button onclick="uploadFiles()">アップロード</button>
    
    <div class="gallery" id="gallery"></div>

    <script>
        async function uploadFiles() {
            const fileInput = document.getElementById('fileInput');
            const files = fileInput.files;
            
            for (const file of files) {
                const formData = new FormData();
                formData.append('file', file);
                
                try {
                    const response = await fetch('/api/upload', {
                        method: 'POST',
                        body: formData
                    });
                    
                    const data = await response.json();
                    
                    if (response.ok) {
                        addImageToGallery(data.filename);
                    }
                } catch (error) {
                    console.error('Error:', error);
                }
            }
            
            fileInput.value = '';
        }

        function addImageToGallery(filename) {
            const gallery = document.getElementById('gallery');
            const img = document.createElement('img');
            img.src = `/uploads/${filename}`;
            gallery.appendChild(img);
        }

        // ページ読み込み時に既存の画像を表示
        async function loadGallery() {
            // 実装は次のステップで
        }

        loadGallery();
    </script>
</body>
</html>
```

---

### 🎓 Day 4 チャレンジ

以下の機能を追加してみよう：

1. アップロードした画像のリストを取得するAPI
2. 画像をクリックすると拡大表示
3. ドラッグ&ドロップでアップロード

---

## 📅 Day 5: 画像生成API（2時間）

### 🎯 目標
- fal.ai APIを使って画像生成
- 非同期処理の理解
- 生成画像の保存と表示

### ステップ5.1: fal.ai APIの基本（30分）

**APIキーの取得**
1. [fal.ai](https://fal.ai/) にアクセス
2. アカウント作成
3. Dashboard → API Keys

**.env に追加**
```bash
FAL_KEY=あなたのfal.aiAPIキー
```

**依存関係をインストール**
```bash
pip install fal-client requests
```

**test_fal.py**
```python
import os
from dotenv import load_dotenv
import fal_client

load_dotenv()
os.environ["FAL_KEY"] = os.getenv("FAL_KEY")

# 画像生成
result = fal_client.subscribe(
    "fal-ai/seedream",
    arguments={
        "prompt": "A beautiful sunset over mountains",
        "num_inference_steps": 20,
        "guidance_scale": 7.5,
        "num_images": 1
    }
)

print("生成された画像URL:")
print(result['images'][0]['url'])
```

```bash
python test_fal.py
```

---

### ステップ5.2: FlaskアプリでA生成（1時間）

**app.py**
```python
import os
import requests
from flask import Flask, render_template, jsonify, request
from dotenv import load_dotenv
import fal_client

load_dotenv()
os.environ["FAL_KEY"] = os.getenv("FAL_KEY")

app = Flask(__name__)
app.config['UPLOAD_FOLDER'] = 'generated'
os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)

@app.route('/')
def index():
    return render_template('image_gen.html')

@app.route('/api/generate', methods=['POST'])
def generate_image():
    try:
        data = request.json
        prompt = data.get('prompt', '')
        
        # 画像生成
        result = fal_client.subscribe(
            "fal-ai/seedream",
            arguments={
                "prompt": prompt,
                "num_inference_steps": 20,
                "guidance_scale": 7.5,
                "num_images": 1
            }
        )
        
        image_url = result['images'][0]['url']
        
        # 画像をダウンロードして保存
        response = requests.get(image_url)
        if response.status_code == 200:
            filename = f"img_{len(os.listdir(app.config['UPLOAD_FOLDER'])) + 1}.png"
            filepath = os.path.join(app.config['UPLOAD_FOLDER'], filename)
            
            with open(filepath, 'wb') as f:
                f.write(response.content)
            
            return jsonify({
                'success': True,
                'filename': filename,
                'url': f'/generated/{filename}'
            })
        
        return jsonify({'success': False, 'error': 'ダウンロード失敗'}), 500
    
    except Exception as e:
        print(f"Error: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/generated/<filename>')
def generated_file(filename):
    return send_from_directory(app.config['UPLOAD_FOLDER'], filename)

if __name__ == '__main__':
    app.run(debug=True)
```

**templates/image_gen.html**
```html
<!DOCTYPE html>
<html>
<head>
    <title>AI画像生成</title>
    <style>
        body {
            font-family: sans-serif;
            max-width: 800px;
            margin: 50px auto;
            padding: 20px;
        }
        #prompt {
            width: 100%;
            padding: 10px;
            margin-bottom: 10px;
        }
        button {
            padding: 10px 20px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        button:disabled {
            background: #ccc;
        }
        #result {
            margin-top: 20px;
        }
        #result img {
            max-width: 100%;
            border-radius: 10px;
        }
        .loading {
            color: #666;
            font-style: italic;
        }
    </style>
</head>
<body>
    <h1>AI画像生成</h1>
    <input type="text" id="prompt" placeholder="生成したい画像を説明...（例：夕日と山）">
    <button onclick="generateImage()" id="generateBtn">画像を生成</button>
    
    <div id="result"></div>

    <script>
        async function generateImage() {
            const prompt = document.getElementById('prompt').value;
            const btn = document.getElementById('generateBtn');
            const resultDiv = document.getElementById('result');
            
            if (!prompt) {
                alert('プロンプトを入力してください');
                return;
            }
            
            btn.disabled = true;
            resultDiv.innerHTML = '<p class="loading">画像を生成中...</p>';
            
            try {
                const response = await fetch('/api/generate', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({prompt: prompt})
                });
                
                const data = await response.json();
                
                if (data.success) {
                    resultDiv.innerHTML = `
                        <h3>生成された画像:</h3>
                        <img src="${data.url}" alt="生成画像">
                        <p>ファイル名: ${data.filename}</p>
                    `;
                } else {
                    resultDiv.innerHTML = `<p style="color: red;">エラー: ${data.error}</p>`;
                }
            } catch (error) {
                console.error('Error:', error);
                resultDiv.innerHTML = '<p style="color: red;">エラーが発生しました</p>';
            } finally {
                btn.disabled = false;
            }
        }
    </script>
</body>
</html>
```

---

### 🎓 Day 5 チャレンジ

以下の機能を追加してみよう：

1. 生成パラメータ（num_inference_steps, guidance_scale）を調整可能に
2. 生成履歴を表示
3. プログレスバーを追加

---

## 📅 Day 6: データ永続化（2時間）

### 🎯 目標
- CSVファイルへのデータ保存
- フォルダー構造の管理
- 会話履歴の読み書き

### ステップ6.1: CSV操作の基本（30分）

**test_csv.py**
```python
import csv
from datetime import datetime
from pathlib import Path

# フォルダー作成
data_folder = Path('data')
data_folder.mkdir(exist_ok=True)

# CSVファイルのパス
csv_file = data_folder / 'messages.csv'

# CSVに書き込み
def save_message(role, content):
    with open(csv_file, 'a', newline='', encoding='utf-8') as f:
        writer = csv.writer(f)
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        writer.writerow([timestamp, role, content])

# CSVから読み込み
def load_messages():
    messages = []
    if csv_file.exists():
        with open(csv_file, 'r', encoding='utf-8') as f:
            reader = csv.reader(f)
            for row in reader:
                if len(row) == 3:
                    messages.append({
                        'timestamp': row[0],
                        'role': row[1],
                        'content': row[2]
                    })
    return messages

# テスト
save_message('user', 'こんにちは')
save_message('assistant', 'こんにちは！元気ですか？')

messages = load_messages()
for msg in messages:
    print(f"[{msg['timestamp']}] {msg['role']}: {msg['content']}")
```

---

### ステップ6.2: 会話フォルダーの管理（45分）

**conversation_manager.py**
```python
import csv
from datetime import datetime
from pathlib import Path

class ConversationManager:
    def __init__(self, base_folder='datas'):
        self.base_folder = Path(base_folder)
        self.base_folder.mkdir(exist_ok=True)
    
    def create_conversation(self):
        """新しい会話フォルダーを作成"""
        timestamp = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
        conv_folder = self.base_folder / timestamp
        conv_folder.mkdir(exist_ok=True)
        
        # imagesフォルダー作成
        images_folder = conv_folder / 'images'
        images_folder.mkdir(exist_ok=True)
        
        # messages.csv作成
        csv_file = conv_folder / 'messages.csv'
        with open(csv_file, 'w', newline='', encoding='utf-8') as f:
            writer = csv.writer(f)
            writer.writerow(['timestamp', 'role', 'content', 'image_refs'])
        
        return str(conv_folder)
    
    def save_message(self, conv_folder, role, content, image_refs=None):
        """メッセージを保存"""
        csv_file = Path(conv_folder) / 'messages.csv'
        with open(csv_file, 'a', newline='', encoding='utf-8') as f:
            writer = csv.writer(f)
            timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            img_refs_str = ','.join(image_refs) if image_refs else ''
            writer.writerow([timestamp, role, content, img_refs_str])
    
    def load_messages(self, conv_folder):
        """メッセージを読み込み"""
        csv_file = Path(conv_folder) / 'messages.csv'
        messages = []
        
        if csv_file.exists():
            with open(csv_file, 'r', encoding='utf-8') as f:
                reader = csv.DictReader(f)
                for row in reader:
                    image_refs = row['image_refs'].split(',') if row['image_refs'] else []
                    messages.append({
                        'timestamp': row['timestamp'],
                        'role': row['role'],
                        'content': row['content'],
                        'image_refs': image_refs
                    })
        
        return messages
    
    def get_next_image_number(self, conv_folder):
        """次の画像番号を取得"""
        images_folder = Path(conv_folder) / 'images'
        existing = list(images_folder.glob('img*.png'))
        
        if not existing:
            return 1
        
        numbers = []
        for img in existing:
            try:
                num = int(img.stem.replace('img', ''))
                numbers.append(num)
            except ValueError:
                continue
        
        return max(numbers) + 1 if numbers else 1

# テスト
if __name__ == '__main__':
    manager = ConversationManager()
    
    # 新しい会話を作成
    conv_folder = manager.create_conversation()
    print(f"会話フォルダー作成: {conv_folder}")
    
    # メッセージを保存
    manager.save_message(conv_folder, 'user', 'こんにちは')
    manager.save_message(conv_folder, 'assistant', 'こんにちは！', ['img1.png'])
    
    # メッセージを読み込み
    messages = manager.load_messages(conv_folder)
    for msg in messages:
        print(msg)
    
    # 次の画像番号
    next_num = manager.get_next_image_number(conv_folder)
    print(f"次の画像番号: {next_num}")
```

---

### ステップ6.3: Flaskアプリに統合（45分）

**app.py（完全版）**
```python
import os
from flask import Flask, render_template, jsonify, request, send_from_directory
from dotenv import load_dotenv
from conversation_manager import ConversationManager

load_dotenv()

app = Flask(__name__)
manager = ConversationManager()

# 現在の会話ID（本来はセッション管理が必要）
current_conversation = None

@app.route('/')
def index():
    return render_template('chat_app.html')

@app.route('/api/new_conversation', methods=['POST'])
def new_conversation():
    global current_conversation
    current_conversation = manager.create_conversation()
    return jsonify({
        'success': True,
        'conversation_id': current_conversation
    })

@app.route('/api/send_message', methods=['POST'])
def send_message():
    global current_conversation
    
    data = request.json
    message = data.get('message', '')
    
    # ユーザーメッセージを保存
    manager.save_message(current_conversation, 'user', message)
    
    # ここでAI応答を生成（Day 3で実装したGeminiを使用）
    ai_response = f"あなたは「{message}」と言いました"
    
    # AI応答を保存
    manager.save_message(current_conversation, 'assistant', ai_response)
    
    return jsonify({
        'success': True,
        'response': ai_response
    })

@app.route('/api/messages', methods=['GET'])
def get_messages():
    global current_conversation
    
    if not current_conversation:
        return jsonify({'success': False, 'error': '会話が開始されていません'})
    
    messages = manager.load_messages(current_conversation)
    return jsonify({
        'success': True,
        'messages': messages
    })

if __name__ == '__main__':
    app.run(debug=True)
```

---

### 🎓 Day 6 チャレンジ

以下の機能を追加してみよう：

1. 過去の会話リストを取得するAPI
2. 特定の会話を読み込む機能
3. 会話を削除する機能

---

## 📅 Day 7: 統合とデバッグ（3時間）

### 🎯 目標
- これまでの知識を統合
- 完全なアプリを作成
- よくあるエラーを修正

### ステップ7.1: 全機能の統合（1.5時間）

これまでのコードを組み合わせて、完全なアプリを作成します。

**最終版 app.py**
```python
# Day 1-6で学んだことを全て統合
# - Flask基礎
# - Gemini API
# - ファイルアップロード
# - 画像生成
# - CSV保存

# 完全なコードは前に提供したものを参照
```

---

### ステップ7.2: よくあるエラーと解決方法（1時間）

**エラー1: ModuleNotFoundError**
```python
# エラー: ModuleNotFoundError: No module named 'flask'
# 解決:
pip install flask
```

**エラー2: KeyError in environment variables**
```python
# エラー: KeyError: 'GOOGLE_AI_API_KEY'
# 解決: .envファイルを確認
# - ファイル名が正しいか（.env.txtではない）
# - APIキーが正しく設定されているか
# - load_dotenv()を呼び出しているか
```

**エラー3: CORS エラー**
```python
# エラー: Access to fetch has been blocked by CORS policy
# 解決:
from flask_cors import CORS
CORS(app)
```

**エラー4: ファイルが見つからない**
```python
# エラー: FileNotFoundError: templates/index.html
# 解決:
# - templatesフォルダーが存在するか確認
# - ファイル名が正しいか確認（大文字小文字も）
```

**エラー5: JSON parse error**
```javascript
// エラー: SyntaxError: Unexpected token < in JSON
// 解決: サーバーがHTMLを返している可能性
// - ルートが正しいか確認
// - エラーレスポンスを適切に処理
```

---

### ステップ7.3: デバッグテクニック（30分）

**1. print文デバッグ**
```python
@app.route('/api/chat', methods=['POST'])
def api_chat():
    data = request.json
    print(f"受信データ: {data}")  # ← 追加
    
    message = data.get('message', '')
    print(f"メッセージ: {message}")  # ← 追加
    
    # ... 処理
```

**2. ブラウザコンソール**
```javascript
// Chromeデベロッパーツール (F12)
console.log('送信データ:', {message: message});

fetch('/api/chat', {...})
    .then(res => {
        console.log('レスポンスステータス:', res.status);
        return res.json();
    })
    .then(data => {
        console.log('受信データ:', data);
    });
```

**3. ネットワークタブ**
```
F12 → Network タブ
- リクエストの内容を確認
- レスポンスの内容を確認
- ステータスコードを確認
```

**4. try-catchを活用**
```python
try:
    # 処理
    response = some_function()
except Exception as e:
    print(f"エラー詳細: {type(e).__name__}: {e}")
    import traceback
    traceback.print_exc()
```

---

### 🎓 Day 7 最終チャレンジ

**完全なAI画像チャットアプリを作成**

要件:
1. Gemini APIで会話
2. 画像をアップロードして分析
3. fal.aiで画像生成
4. 会話をCSVに保存
5. 画像をimg1.png, img2.png...と保存
6. エラーハンドリング

---

## 🎯 総まとめ: 理解度チェックリスト

### Flask基礎
- [ ] ルーティングの仕組みを理解
- [ ] テンプレートの使い方を理解
- [ ] POSTリクエストの処理を理解
- [ ] JSONレスポンスを理解

### フロントエンド
- [ ] HTML/CSS/JavaScriptの基本を理解
- [ ] Fetch APIでサーバーと通信できる
- [ ] DOMを操作できる
- [ ] イベントリスナーを使える

### API連携
- [ ] 環境変数の使い方を理解
- [ ] Gemini APIで文章生成できる
- [ ] fal.aiで画像生成できる
- [ ] エラーハンドリングができる

### ファイル操作
- [ ] ファイルアップロードを実装できる
- [ ] 画像をプレビュー表示できる
- [ ] CSVの読み書きができる
- [ ] フォルダー構造を管理できる

---

## 📚 さらなる学習リソース

### 公式ドキュメント
- Flask: https://flask.palletsprojects.com/
- MDN Web Docs (JavaScript): https://developer.mozilla.org/ja/
- Google Gemini API: https://ai.google.dev/

### おすすめチュートリアル
- Flask Mega-Tutorial: https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-i-hello-world
- JavaScript.info: https://javascript.info/
- fal.ai Docs: https://fal.ai/docs

---

## 🎉 おめでとうございます！

7日間のプログラムを完了すれば、あなたは：
- ✅ Flaskで本格的なWebアプリを作れる
- ✅ フロントエンドとバックエンドを連携できる
- ✅ 外部APIを統合できる
- ✅ ファイルとデータを適切に管理できる

**次のステップ:**
1. このアプリをカスタマイズして自分のプロジェクトを作る
2. 他の機能を追加（認証、データベース、デプロイなど）
3. 学んだスキルで新しいアプリを作る

頑張ってください！ 🚀
